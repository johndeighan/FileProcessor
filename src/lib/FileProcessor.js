// Generated by CoffeeScript 2.7.0
  // FileProcessor.coffee
import {
  undef,
  defined,
  notdefined,
  getOptions,
  isString,
  isHash
} from '@jdeighan/base-utils';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  mkpath,
  pathType,
  parseSource,
  allFilesIn,
  allLinesIn
} from '@jdeighan/base-utils/fs';

import {
  dbgEnter,
  dbgReturn,
  dbg
} from '@jdeighan/base-utils/debug';

// ---------------------------------------------------------------------------
export var FileProcessor = class FileProcessor {
  constructor(path1, hOptions = {}) {
    this.path = path1;
    // --- path can be a file or directory
    // --- Valid options:
    //        recursive
    dbgEnter('FileProcessor', hOptions);
    assert(isString(this.path), "path not a string");
    this.hOptions = getOptions(hOptions, {
      recursive: true
    });
    // --- determine type of path
    this.pathType = pathType(this.path);
    assert((this.pathType === 'dir') || (this.pathType === 'file'), `path type ${this.pathType} must be dir or file`);
    // --- convert path to a full path
    this.path = mkpath(this.path);
    this.numFiles = 0;
    this.hNumLines = {}; // { <filePath> => <numLines>, ... }
    dbgReturn('FileProcessor');
  }

  // ..........................................................
  totalLines() {
    var i, len, path, ref, tot;
    tot = 0;
    ref = Object.keys(this.hNumLines);
    for (i = 0, len = ref.length; i < len; i++) {
      path = ref[i];
      tot += this.hNumLines[path];
    }
    return tot;
  }

  // ..........................................................
  go() {
    var count, hFileInfo, hOpt, name, ref;
    this.begin();
    count = 0;
    switch (this.pathType) {
      case 'file':
        hFileInfo = parseSource(this.path);
        name = hFileInfo.fileName;
        count = 1;
        if (this.filterFile(hFileInfo)) {
          dbg(`[${count}] ${name} - Handle`);
          this.handleFile(hFileInfo);
        } else {
          dbg(`[${count}] ${name} - Skip`);
        }
        break;
      case 'dir':
        dbg(`process all files in '${this.path}'`);
        hOpt = {
          recursive: !!this.hOptions.recursive
        };
        ref = allFilesIn(this.path, hOpt);
        for (hFileInfo of ref) {
          name = hFileInfo.fileName;
          count += 1;
          if (this.filterFile(hFileInfo)) {
            dbg(`[${count}] ${name} - Handle`);
            this.handleFile(hFileInfo);
          } else {
            dbg(`[${count}] ${name} - Skip`);
          }
        }
    }
    dbg(`${count} files processed`);
    this.end();
  }

  // ..........................................................
  // --- called at beginning of @go()
  begin() {
    dbg("begin() called");
  }

  // ..........................................................
  // --- called at end of @go()
  end() {
    dbg("end() called");
  }

  // ..........................................................
  filterFile(hFileInfo) {
    return true; // by default, handle all files in dir
  }

  
    // ..........................................................
  // --- default handleFile() calls handleLine() for each line
  handleFile(hFileInfo) {
    // --- if we're here, then filterFile() returned true
    this.beginFile(hFileInfo);
    this.procFile(hFileInfo);
    this.endFile(hFileInfo);
    this.numFiles += 1;
  }

  // ..........................................................
  beginFile(hFileInfo) {}

  // ..........................................................
  recordNumLines(path, numLines) {
    this.hNumLines[path] = numLines;
  }

  // ..........................................................
  procFile(hFileInfo) {
    var filePath, hResult, line, numLines, ref;
    assert(defined(hFileInfo), "procFile(): hFileInfo = undef");
    filePath = hFileInfo.filePath;
    numLines = 0;
    ref = allLinesIn(hFileInfo.filePath);
    for (line of ref) {
      numLines += 1;
      if (this.filterLine(line, numLines + 1, hFileInfo)) {
        hResult = this.handleLine(line, numLines + 1, hFileInfo);
        if (defined(hResult)) {
          assert(isHash(hResult), "handleLine() return not a hash");
          if (hResult.abort) {
            this.recordNumLines(filePath, numLines);
            return;
          }
        }
      }
    }
    this.recordNumLines(filePath, numLines);
  }

  // ..........................................................
  endFile(hFileInfo) {} // by default, does nothing

  
    // ..........................................................
  filterLine(line, lineNum, hFileInfo) {
    return true; // by default, handle all lines in file
  }

  
    // ..........................................................
  handleLine(line, lineNum, hFileInfo) {} // by default, does nothing

};

// --- if we're here, then filterLine() returned true
